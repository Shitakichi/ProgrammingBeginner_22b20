# 概要と目的
- アドレスについて学ぶ
- ポインタについて学ぶ
- `scanf()`関数を深く理解する

# 8-1.変数のアドレス
## (1) 変数にはアドレスがある
lesson1で変数はメモリ上に配置されることを学習しました。

![変数](./_attachments/変数.drawio.svg)

メモリには、場所を示すための住所があります。それがアドレスです。アドレスは連番に割り振られています。図で言えば`0x0000`などがアドレスです。この講義ではこのアドレスを用いたプログラミング方法を説明します。

変数の前に「`&`」を付けると、変数のアドレスを確認することができます。例えば`a`という変数があると、`&a`とすることにより、変数のアドレスを取得することができます。

```c
/* sample1.c */
#include <stdio.h>

int main(int argc,char** argv){
    int a = 100;		//	int型の変数
    double b = 123.4;	//	double型の変数
    float c = 123.4f;	//	float型の変数(数値の後ろにfつける)
    char d = 'a';		//	char型の変数
    printf("aの値は%d、大きさは%dbyte、アドレスは0x%p\n",a,sizeof(int),&a);
    printf("bの値は%f、大きさは%dbyte、アドレスは0x%p\n",b,sizeof(double),&b);
    printf("cの値は%f、大きさは%dbyte、アドレスは0x%p\n",c,sizeof(float),&c);
    printf("dの値は%c、大きさは%dbyte、アドレスは0x%p\n",d,sizeof(char),&d);
    return 0;
}
```

```sh
# 実行結果(実行する度に変化する)
aの値は100、大きさは4byte、アドレスは0xd7fc94
bの値は123.400000、大きさは8byte、アドレスは0xd7fc84
cの値は123.400002、大きさは4byte、アドレスは0xd7fc78
dの値はa、大きさは1byte、アドレスは0xd7fc6f
```

## (2) sizeof演算子
このプログラムの中に出てくる`sizeof(サイズオブ)`演算子は、変数や型のメモリのサイズを取得する演算子です。`()`の中に変数や、型を入れれば、そのサイズをバイト単位で取得することが可能です。

```c
sizeof(int) // int型のサイズを取得
sizeof(a)   // 変数aのサイズを取得
```

sample1.cを実行すれば、`a`,`b`,`c`,`d`の4つの変数の、メモリ空間上で占めるメモリの大きさをバイト数で、そしてそのアドレスを取得できます。`a`,`b`,`c`,`d`は、それぞれ違う型の変数ですが、アドレスは整数型として取得されます。printf()関数の中で`%p`書式で表示すれば、その結果が表示されます。

実行結果から、各変数には、固有のアドレスとサイズがあることがわかります。

実行環境によって、変数のアドレスは変わるので、実行結果の数値はこの値と一致しないと思われます。しかし、どの変数にもアドレスがあり、型に依存した固有のサイズがあるという事実は変わりません。

> [!TIP]
> メモリはアドレスがあり、値を格納できる
> メモリに値を保存したいときは**アドレス**と**値のサイズ**が必要
> ただ、アドレスは分かりずらいので、**先頭のアドレス**名前を付けたものが変数である

# 8-2.ポインタ
## (1) ポインタとは
このように、変数には値のほかに、その値を格納するアドレスがあることがわかりました。つまり、変数には値とアドレス、二つの側面があるのです。通常の変数は値を入れることを前提としています。

しかし、C言語には、アドレスを入れることを前提とした変数が存在します。それをポインタ変数もしくは、単にポインタと言います。ポインタ変数は例えば以下のように定義をします。

```c
// intの場合
int *p;
```

このように、先頭に`*`をつけると、その変数がポインタ変数であることを示すことができます。ではポインタ変数を使ったサンプルを見てみましょう。

```c
/* sample2.c */
#include <stdio.h>

int main(int argc,char** argv){
    int a = 100;
    char b = 'a';

    printf("aのアドレス %p\n", &a);
    printf("bのアドレス %p\n", &b);

    // ポインタ変数の宣言
    int *pa;
    char *pb;
    
    // ポインタ変数への代入
    pa = &a;
    pb = &b;

    // ポインタ変数の参照と関節参照
    printf("aのアドレス %p, aの値 %d\n", pa, *pa);
    printf("bのアドレス %p, bの値 %c\n", pb, *pb);

    *pa = 50;
    printf("aのアドレス %p, aの値 %d\n", pa, *pa);
    printf("bのアドレス %p, bの値 %c\n", pb, *pb);

    return 0;
}
```

```sh
# 実行結果
aのアドレス 0x50a3a8
bのアドレス 0x50a3e0
aのアドレス 0x50a3a8, aの値 100
bのアドレス 0x50a3e0, bの値 a
aのアドレス 0x50a3a8, aの値 50
bのアドレス 0x50a3e0, bの値 a
```

以下の部分で変数aと変数bのアドレスをポインタ変数に代入しています。
```c
// ポインタ変数への代入
pa = &a;
pb = &b;
```

そのため、そのままpa, pbの値を表示させると、aのアドレス, bのアドレスを表示することになります。

ポインタ変数に`*`を付けて参照すると、ポインタ変数が持っているアドレスをたどり、そのアドレスにある値を参照することができます。このような参照方法を間接参照と呼びます。
```c
// ポインタ変数の参照と関節参照
printf("aのアドレス %p, aの値 %d\n", pa, *pa);
printf("bのアドレス %p, bの値 %c\n", pb, *pb);

*pa = 50;
printf("aのアドレス %p, aの値 %d\n", pa, *pa);
printf("bのアドレス %p, bの値 %c\n", pb, *pb);
```

では、ポインタ変数がメモリ上ではどのように配置されているのか示します。
![ポインタ変数](./_attachments/ポインタ変数.drawio.svg)
ではここで応用問題です！`&pa`の値は何を示すでしょうか？

## (2) NULLによる初期化
ポインタ変数に`NULL`という定数を代入すると、ポインタ変数に値が格納されていないことを表現することができます。

初期化する時に、代入するアドレスがまだ決まってっていない場合などの時は`NULL`を代入しましょう。

```c
int* p = NULL;
```

なのでsample1.cのポインタ変数の宣言文は以下の方が良いです！
```c
// ポインタ変数の宣言
int *pa = NULL;
char *pb = NULL;
```

## (3) ポインタの注意点
ポインタに変数のアドレスを設定するときは、原則的に同じ型のポインタ変数でするようにしましょう。例えば、「`int a`」であれば、「`int *p`」、「`double d`」であれば、「`double *pd`」といったように、対応する型をあわせるようにしましょう。型が違っても、コンパイルエラーにはなりませんが、実行時に致命的なエラーになる可能性があります。

# 8-3.ポインタの応用
## (1) ポインタを使う場面
さて先ほどの章で、ポインタの基本的な使い方をマスターできました。しかし、ポインタっていつ使うねんとなっているかと思います。ここではよくポインタが利用される場面を紹介します。

ポインタ変数は関数の引数によく使われます。lesson7で学習した関数ですが、ここで少し復習してみましょう。

下記のプログラムを実行すると、どのような出力が得られるか分かりますか？
```c
/* sample3.c */
#include <stdio.h>

// 合計と平均を計算する関数
void get_sum_and_avg(int a, int b, int sum, double avg){
    sum = a+b;
    avg = sum/2.0;
    return;
}

int main(void) {
    int a=5;
    int b=8;
    int sum=0;
    double avg=0;

    get_sum_and_avg(a, b, sum, avg);
    
    printf("a=%d, b=%d, sum=%d, avg=%f", a, b, sum, avg);

    return 0;
}
```

```sh
# 求めている実行結果
a=5, b=8, sum=13, avg=6.500000
```

求めている実行結果のようになると思うかもしれませんが、実際は以下のような出力になります。

```sh
# 実行結果
a=5, b=8, sum=0, avg=0.000000
```

どうして`sum`と`avg`の値が変わっていないのでしょうか？これは引数の変数は、呼び出し側の変数の値のみを複製して、代入されているからです。

![関数の引数](./_attachments/関数の引数.drawio.svg)

このように関数の引数は、呼び出し元の値を複製します。そのため、大きな構造体などを引数に渡してしまうと、複製に時間がかかり、実行速度が落ちてしまいます。

また、呼び出し元の変数の値を関数の中から変更したい場合(求めている実行結果にしたい場合)もあるでしょう。

これら2つの問題を解決できるのがポインタ変数です。
1. 引数の複製に時間がかかる
2. 関数内から呼び出し元の変数の値を変更したい

## (2) 引数としてポインタ変数をとる関数
以下のように変更することで、関数内から呼び出し元の変数の値を変更できます。

```c
/* sample4.c */
#include <stdio.h>

// 合計と平均を計算する関数
void get_sum_and_avg(int a, int b, int *sum, double *avg){
    *sum = a+b;
    *avg = *sum/2.0;
    return;
}

int main(void) {
    int a=5;
    int b=8;
    int sum=0;
    double avg=0;

    get_sum_and_avg(a, b, &sum, &avg);
    
    printf("a=%d, b=%d, sum=%d, avg=%f", a, b, sum, avg);

    return 0;
}
```

```sh
# 実行結果
a=5, b=8, sum=13, avg=6.500000
```

関数の引数は、呼び出し元の値を複製するのでした。そのため、引数にアドレスを渡すと、アドレスを複製することに、そのアドレスを使い、元の変数に関節参照できます。

![関数のポインタ引数](./_attachments/関数のポインタ引数.drawio.svg)

さらに、引数にポインタ変数を使うことで、アドレス分の複製しか発生せず、大きな構造体であっても、引数の複製に時間がかかりません。

## (3) scanf()関数
ここまで学習すると、`scanf()`関数の引数にアドレスを渡す意味が理解できるでしょう！

```c
int a;
scanf("%d", &a);
```

## (4) まとめ
ポインタ変数を関数の引数に利用すると以下の利点があることが分かりました。
1. 引数の複製に時間がかかる
2. 関数内から呼び出し元の変数の値を変更したい
3. 戻り値の個数を実質増やせる

# 8-4.C言語の終わり
これで一通りC言語の基本を学習し終えました。

よく頑張りました！

でもまだまだ、「文字列」や「共用体」、「ファイルの分割」など扱っていない部分もあります。

ただここまで学習できた皆さんなら、自分で十分学ぶことができるでしょう！

分からないことがあれば先輩たちがいるので、質問してみてください！
